# How to work on each step
Step 1: 答えを見ずに 5 分以内に解く。わからなかったら答えを見て、開始から答えを見ないで 5 分以内に正解になるところまで行う。
Step 2: 本協会メンバーや LeetCode の過去解答を参考にしつつ、コードを見やすくする形で整える。
Step 3: 全部消して、10 分以内にエラーを一度も出さずに正解するのを 3 回続けて行う。
Step 4: いただいたレビューをもとに、コードを整える。

# Comments

## Step 1
全くわからなかった。
文字列の一致のように、並びを記録して一個づづ長くしていく方法を考えたが、それでリンクリストのループを検知できないなとなった。Ex.)1204204見たいな列でループしてるのは204020なのに204を誤検知しそう。しかも一個づつ伸ばしていくと途中からのループに気がつけない。

まずは、このコードを参考にしてみる。https://github.com/cheeseNA/leetcode/blob/141/141.%20Linked%20List%20Cycle/step1.py

なるほど、値の一致を判定するのではなく、ポインタの一致を判定するんだ。

今までPythonの型ヒントを使ってなかったので調べる。

head: Optonal[listnode]
これはhead変数をリンクリストまたはNoneで受け取る。

なるほど。LeetCode側ですでにPythonでのリンクリストは定義されているから、それを利用するということか。コメントアウトされていたのでどういうことなんだろうと思っていた。
あと、Pythonのリストは動的配列だからリンクリストじゃないよな？と一応ドキュメントを確認しにいった。また標準ライブラリにもリンクリストがないためあらかじめ用意していたということだろうか。


Geminiによるソースコードの解説

'''
アルゴリズム：フロイドの「亀とウサギ」 🐢🐇
このコードは**「フロイドのサイクル検出アルゴリズム」、通称「亀とウサギのアルゴリズム」**と呼ばれる手法を使っています。

考え方はとてもシンプルです。

リンクリスト上に、2つのポインタ（カーソル）を用意します。

遅いポインタ（slow_cursor 🐢）は、一度に1つずつノードを進みます。

速いポインタ（fast_cursor 🐇）は、一度に2つずつノードを進みます。

もしリストにサイクルがなければ、速いウサギは必ず先にゴール（リストの終端 None）に到着します。

しかし、もしリストにサイクル（円形のトラックのようなもの）があれば、速いウサギは周回遅れで必ず亀に追いつきます。つまり、どこかの時点で2つのポインタが同じノードを指すことになります。
'''

なるほど、値を比べるのではなくポインタを比べれば同じところにいることが確認できる。
Pythonの＝＝とisはどう違うんだ？
＝＝は値の比較、isは同一性の比較

6.10.1. 値の比較より
オブジェクトの値は Python ではやや抽象的な概念です: 例えば、オブジェクトの値にアクセスする正統な方法はありません。 また、その全てのデータ属性から構成されるなどの特定の方法で、オブジェクトの値を構築する必要性もありません。 比較演算子は、オブジェクトの値とは何かについての特定の概念を実装しています。 この比較の実装によって、間接的にオブジェクトの値を定義していると考えることもできます。

geminiより
小さな整数や短い文字列の罠
Pythonは効率化のために、-5から256までの整数や一部の短い文字列をあらかじめメモリ上に用意して使い回します。そのため、これらの値では is が True になることがありますが、それに頼ったコードを書くべきではありません。

None はプログラム全体で常に一つしか存在しない特別なオブジェクトなので、is で比較するのが最も確実で高速です。

なるほど、基本的にはそういう考えでいるのが良いのか。

あと、以前Atcoderをやっていたので標準入力の受付まで考慮しなくてはいけないのかと思って混乱した。そこは考慮しなくて良いらしい。ここは慣れの部分か。

## Step 2
Step1で下調べをしっかりしたおかげか驚くくらいスムーズに書けた。暗記の部分もある。

## Step 3
ここもスムーズにかけた。一点だけ、手本にしたコードと比べて最初のheadのFalse判定は変えている。これは調べの中でNoneの判定はisで判定した方が良さそうということで書いている。どちらが良いかについては無自覚で書いたが、個人的にはこちらの方が読む時に意図が明確に感じている。


https://github.com/yakataN/Arai60/blob/Linked-List-Cycle/Linked%20List%20Cycle/Linked%20List%20Cycle.md

こちらのStep3でSetを使った方法が紹介されていた。
Setのin演算子が気になったのでドキュメントを読んでみる。

6.10.2. 所属検査演算より
式 x in y は any(x is e or x == e for e in y) と等価です。

これみると、inで成立することは理解できた。同時に、使うの怖いときがあるなと感じる。
一応step3_a.pyとして実装してみた。